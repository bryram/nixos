##
#   My Bash Configs
##

# Set EDITOR to nvim
export EDITOR=nvim
export HIGHLIGHT_STYLE=github

# Check if the current shell is an SSH session
is_ssh_session() {
  if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ]; then
    return 0
  else
    return 1
  fi
}

# PS1 Config
function set_ps1_prompt() {
  local git_branch=""
  local flake_icon=""
  local cur_dir=""

  # Check if we're inside a git repository
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    # If we are, get the current branch name
    git_branch="$(git symbolic-ref --short HEAD 2>/dev/null)"

    # If the command failed, we're in a detached HEAD state, so get the short SHA
    if [ $? -ne 0 ]; then
      git_branch="$(git rev-parse --short HEAD 2>/dev/null)"
    fi

    # Wrap the branch name and : in braces and color it red
    git_branch=" \[\033[01;31m\]$git_branch󰘬:\[\033[00m\]"

    # Check if flake.nix file exists
    if [ -f "$(git rev-parse --show-toplevel)/flake.nix" ]; then
        # If it exists, set the flake icon and color it blue
        flake_icon="\[\033[01;34m\] \[\033[00m\]"
    fi

    # Get the root directory of the git repository
    git_root="$(basename "$(git rev-parse --show-toplevel)")"

    # Get the current directory relative to the Git root
    cur_dir=$(realpath --relative-to=$(git rev-parse --show-toplevel) .)
    if [ "$cur_dir" == "." ]; then
      cur_dir="\[\033[01;34m\] $git_root\[\033[00m\]"
    else
      cur_dir="\[\033[01;34m\] $git_root/$cur_dir\[\033[00m\]"
    fi
  else
    # If not in a Git repository, just show the normal path
    cur_dir="\[\033[01;34m\]\w\[\033[00m\]"
  fi

  if [ -n "${IN_NIX_SHELL:+x}" ]; then
    PS1="$cur_dir\n$flake_icon\[\033[01;32m\]nixShell>$git_branch\[\033[00m\]"
  else
    if ! is_ssh_session; then
      PS1="\n$cur_dir\n$flake_icon\[\033[01;32m\]>$git_branch\[\033[00m\]"
    else
      PS1="\n\[\033[01;34m\]\w\[\033[00m\]\n\[\033[01;32m\]\u@\h:\[\033[00m\] "
    fi
  fi
  unset flake_icon
}
PROMPT_COMMAND="set_ps1_prompt; $PROMPT_COMMAND"

# Locate and source the bash-completion scripts
bash_completion_dir="$HOME/.nix-profiles/share/bash-completion/completions"
if [ -d "$bash_completion_dir" ]; then
  for file in "$bash_completion_dir"/*; do
    source "$file" 2>/dev/null
  done
fi

# Alias List
  alias vi='nvim'
  alias vim='nvim'
  alias v='nvim'
  alias ls='lsd'


##
#     Custom Functions
##

# cd to git root
function cdg() {
  # Check for --help flag
  if [[ $1 == "--help" ]]; then
    echo "A simple utility for navigating to the root of a git repo"
    return 0
  fi

  # Check for invalid command
  if [[ -n "$1" ]]; then
    echo "Invalid command: $1. Try 'cdg --help'."
    return 1
  fi

  # Find the root of the git repository
  local root_dir
  root_dir=$(git rev-parse --show-toplevel 2>/dev/null)
  local git_status=$?

  # Check for git rev-parse failure
  if [ $git_status -ne 0 ]; then
    echo "Error: Not a git repo."
    return 1
  fi

  # If we're inside a git repo, cd to the root
  cd "$root_dir"
}

# penpot {run|stop|update|help} alias function
function penpot() {
  case "$1" in
    run)
      sudo docker compose -p penpot -f ~/Documents/tools/penpot/docker-compose.yaml up -d >/dev/null 2>&1
      nohup bash -c '(sleep 10 && if [[ "$OSTYPE" == "linux-gnu"* ]]; then
                        xdg-open "http://localhost:9001"
                      elif [[ "$OSTYPE" == "darwin"* ]]; then
                        open "http://localhost:9001"
                      fi)' >/dev/null 2>&1 &
      echo "Started penpot on http://localhost:9001"
      ;;
    stop)
      echo "Stopping penpot"
      sudo docker compose -p penpot -f ~/Documents/tools/penpot/docker-compose.yaml down >/dev/null 2>&1
      ;;
    update)
      sudo docker compose -f ~/Documents/tools/penpot/docker-compose.yaml pull
      echo "Updated penpot!"
      ;;
    help)
      xdg-open "https://help.penpot.app/"
      echo "Opened penpot help page in your browser."
      ;;
    *)
      echo "Usage: penpot {run|stop|update|help}"
      ;;
  esac
}

# Developer Environment Function
function dev() {
  echo "Select an environment:"
  echo "1. Web"
  echo "2. Elixir"
  echo "3. Haskell"
  # Add more options here...

  read -p "Enter the number of your choice: " choice

  case $choice in
    1)
      (cd ~/Documents/developerEnvs/webDev && nix develop)
      ;;
    2)
      (cd ~/Documents/developerEnvs/elixirDev && nix develop)
      ;;
    3)
      (cd ~/Documents/developerEnvs/haskellDev && nix develop)
      ;;
    # Add more cases here...
    *)
      echo "Invalid choice"
      ;;
  esac
}

eval "$(direnv hook bash)"
